一、招银
1.索引失效
*发生了隐式类型转换，如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
 如：select * from tbl where id = 111
*对索引列进行运算，包括（+,-,*,/,!）
 如：select * from tbl where id - 1 = 1
*在索引列使用Oracle内部函数,对于这样情况应当创建基于函数的索引
 如：select * from tbl where round(id) = 10
*like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。
*or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
*在索引列上使用 IS NULL , IS NOT NULL , != 操作，索引可能失效(注意是可能!)  https://mp.weixin.qq.com/s/CEJFsDBizdl0SvugGX7UmQ
*当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效
*组合索引，没有使用第一列索引
 如：creat index test on tbl(id,name,age);
     select * from tbl where name = 'LAY' and age = '18'   没有使用id上的索引

2.聚集索引
https://mp.weixin.qq.com/s/8nx4yLOg542p_fmqjKDrKw

3.explain
作用：查看sql的执行计划，用来优化执行时间较久的语句。只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划
参数：*id：id值越大，优先级越高，越先执行
     *select_type：查询类型
     *table：显示这一行数据关于哪张表
     *type:在表中找到所需行的方式，又称访问类型
           常用类型：ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）
     *possible_keys:指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
     *Key：显示MySQL实际决定使用的键（索引）
     *key_len：表示索引中使用的字节数
     *ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
     *rows：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数
     *Extra：该列包含MySQL解决查询的详细信息

4.dispatcherServlet流程? 是否单例?
   本质还是一个servlet,生命周期是跟随容器的，所以只有一个实例。详细流程：https://www.jianshu.com/p/8a20c547e245

5.synchronized 和 Lock 区别
*存在层次：synchronized为关键字，Lock是一个接口
*锁的释放：synchronized：已获取锁的线程执行完同步代码，释放锁，如果线程执行发生异常，jvm会让线程释放锁； Lock：必须要在finally中通过unlock释放锁，否则容易造成死锁。
*锁的获取：synchronized：假设A线程获得锁，B线程等待，如果A阻塞，B会一直等待； Lock：分情况而定，Lock有多种获取锁的方式，可以尝试获得锁，不必一直等待。
*锁状态：  synchronized：无法判断； Lock：可以判断，tryLock
*锁类型：  synchronized：可重入，不可中断，非公平； Lock：可重入，可中断，可公平（两者都可）
*synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度
*性能：    在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。
           到了Java1.6，synchronize进行了很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。

6.自旋锁
*定义：当一个线程获取锁时，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断是否能成功获取到锁，直到获取到锁才退出循环
*优点：自旋锁不会使线程状态发生切换，线程一直都是active的，不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。
*缺点：在持有锁的线程占用锁时间过长或锁的竞争过于激烈的情况下，线程在自旋过程中会长时间获取不到锁资源，将引起CPU的浪费。

7.线程有哪些状态
*新建状态（New）：新建了一个线程对象
*就绪状态（Runnable）：其它线程调用了start()，该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，其它运行所需资源已全部获得。
*运行状态（Running）：就绪状态的线程获取到了CPU
*阻塞状态（Blocked）：因为某种原因放弃CPU使用权，暂时停止运行。直到线程重新进入就绪状态，才有机会重新运行。（调用了sleep(),join(),wait()等方法，或者获取对象同步锁时发现被其它线程占用）
*死亡状态（Dead）：线程已执行完毕或因异常退出了run()方法

8.HashMap、HashTable、ConcurrentHashMap

9.什么是幂等性（idempotent），put和post的区别
在编程中一个幂等操作的特点是执行多次或一次，其影响是相同的，所以get,put,delete都是幂等的
put一般用于更新操作，具有幂等性,post一般用于新增资源，不具备幂等性



