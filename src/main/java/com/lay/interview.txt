一、招银
1.索引失效
*发生了隐式类型转换，如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
 如：select * from tbl where id = 111
*对索引列进行运算，包括（+,-,*,/,!）
 如：select * from tbl where id - 1 = 1
*在索引列使用Oracle内部函数,对于这样情况应当创建基于函数的索引
 如：select * from tbl where round(id) = 10
*like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。
*or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
*在索引列上使用 IS NULL , IS NOT NULL , != 操作，索引可能失效(注意是可能!)  https://mp.weixin.qq.com/s/CEJFsDBizdl0SvugGX7UmQ
*当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效
*组合索引，没有使用第一列索引
 如：creat index test on tbl(id,name,age);
     select * from tbl where name = 'LAY' and age = '18'   没有使用id上的索引

2.聚集索引
https://mp.weixin.qq.com/s/8nx4yLOg542p_fmqjKDrKw

3.explain
作用：查看sql的执行计划，用来优化执行时间较久的语句。只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划
参数：*id：id值越大，优先级越高，越先执行
     *select_type：查询类型
     *table：显示这一行数据关于哪张表
     *type:在表中找到所需行的方式，又称访问类型
           常用类型：ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）
     *possible_keys:指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
     *Key：显示MySQL实际决定使用的键（索引）
     *key_len：表示索引中使用的字节数
     *ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
     *rows：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数
     *Extra：该列包含MySQL解决查询的详细信息

4.dispatcherServlet流程? 是否单例?
   本质还是一个servlet,生命周期是跟随容器的，所以只有一个实例。详细流程：https://www.jianshu.com/p/8a20c547e245

5.synchronized 和 Lock 区别
*存在层次：synchronized为关键字，Lock是一个接口
*锁的释放：synchronized：已获取锁的线程执行完同步代码，释放锁，如果线程执行发生异常，jvm会让线程释放锁； Lock：必须要在finally中通过unlock释放锁，否则容易造成死锁。
*锁的获取：synchronized：假设A线程获得锁，B线程等待，如果A阻塞，B会一直等待； Lock：分情况而定，Lock有多种获取锁的方式，可以尝试获得锁，不必一直等待。
*锁状态：  synchronized：无法判断； Lock：可以判断，tryLock
*锁类型：  synchronized：可重入，不可中断，非公平； Lock：可重入，可中断，可公平（两者都可）
*synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度
*性能：    在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。
           到了Java1.6，synchronize进行了很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。

6.自旋锁
*定义：当一个线程获取锁时，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断是否能成功获取到锁，直到获取到锁才退出循环
*优点：自旋锁不会使线程状态发生切换，线程一直都是active的，不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。
*缺点：在持有锁的线程占用锁时间过长或锁的竞争过于激烈的情况下，线程在自旋过程中会长时间获取不到锁资源，将引起CPU的浪费。

7.synchronized 修饰在 static方法和非static方法的区别
*修饰static方法：多线程下，获取的是类锁（即Class本身，注意：不是实例），作用范围是整个静态方法，作用的对象是这个类的所有对象。
*修饰非static方法：多线程下，获取的是对象锁（即类的实例对象），作用范围是整个方法，作用对象是调用该方法的对象。不同对象间没有竞争关系

8.线程有哪些状态
*新建状态（New）：新建了一个线程对象
*就绪状态（Runnable）：其它线程调用了start()，该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，其它运行所需资源已全部获得。
*运行状态（Running）：就绪状态的线程获取到了CPU
*阻塞状态（Blocked）：因为某种原因放弃CPU使用权，暂时停止运行。直到线程重新进入就绪状态，才有机会重新运行。（调用了sleep(),join(),wait()等方法，或者获取对象同步锁时发现被其它线程占用）
*死亡状态（Dead）：线程已执行完毕或因异常退出了run()方法

9.HashMap、HashTable、ConcurrentHashMap

10.什么是幂等性（idempotent），put和post的区别
在编程中一个幂等操作的特点是执行多次或一次，其影响是相同的，所以get,put,delete都是幂等的
put一般用于更新操作，具有幂等性,post一般用于新增资源，不具备幂等性

11.git提交文件步骤
*

12.git pull 和fetch 的区别

13.Maven中常用命令

14.IOC,AOP

15.单例模式

16.事务管理

17.多线程


二、封面新闻
1.想要在数据库中存储emoji表情，需要怎么操作
emoji表情为4个字节的字符，而utf8字符集只支持1-3个字节的字符，所以需要将字符集修改为支持1-4个字节的utf8mb4

2.cookie和session的区别和联系
区别： 1.cookie存在本地浏览器上，session存在服务器上
       2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session
       3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE
       4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie

联系：session是通过cookie来工作的，sessionID以cookie的形式存在浏览器中。

3.有哪些GC策略以及它们各自的优点(https://javadoop.com/post/jvm-memory-management)
Serial(串行收集器)：适合内存有限的情况下，但回收慢
Parallel(并行收集器)：效率高，但当Heap过大时，应用程序暂停时间较长
CMS(Concurrent Mark-Sweep 并发收集器)：Old区回收暂停时间短，但产生内存碎片、整个GC耗时长、比较耗CPU
G1(Garbage First)：可设置预期的停顿时间，不产生内存碎片，但只适合大内存，一般6G以上，小内存不适用

4.有几种类加载器？它们的父子关系是怎样的？双亲委派？什么场景下使用自定义类加载器？（https://blog.csdn.net/codeyanbao/article/details/82875064）

                                        Bootstrap classLoader：主要负责加载核心的类库(rt.jar等)，构造ExtClassLoader和APPClassLoader
                                                 ↑
                                           ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar
                                                 ↑
                                           AppClassLoader：主要负责加载用户路径CLASSPATH路径下的类包
                                                 ↑向上委托
                                           用户自定义加载器：负责加载用户自定义路径下的类包

双亲委派机制：当一个类加载器收到了类加载请求，如果这个类没有被加载过，它首先不会尝试自己去加载这个类，而是把这个请求委派给父加载器去完成，
             每一个层次类加载器都是如此，因此所有的加载请求都应该传到启动类加载，只有当父类加载器反馈自己无法完成这个请求时（在它的加载
             路径下没有找到所需的Class），子类加载器才会尝试自己去加载。

双亲委派优势：1.沙箱安全机制：比如自己写的String.class类不会被加载，因为这种系统级别的类已经被Bootstrap classLoader加载了（最先尝试加载），
                           这样可以防止核心库被随意篡改。
             2.避免类重复加载：当父ClassLoader已经加载了该类的时候，就不需要子加载器再加载一次。

自定义加载器应用场景：隔离加载类、修改类加载的方式、扩展加载源、防止源码泄露








