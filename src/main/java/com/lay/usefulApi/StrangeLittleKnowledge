1.YYYY与yyyy的区别
  大多数情况下格式日期都是用的SimpleDateFormat，比如说把一个日期格式成"yyyy-MM-dd"的形式。对于年份来说，大写的Y和小写的y其意义是不同
的。y 是Year,Y 表示的是Week year。Week year 意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，那么这周就算入下一年。

2.BigDecimal
  i)禁止使用构造方法BigDecimal(double)的方式把double值转为BigDecimal对象。
    BigDecimal(double)存在精度损失风险，如 BigDecimal b = new BigDecimal(0.1F);实际存储的值为0.10000000149
    优先推荐入参为String的构造方法或使用BigDecimal的valueOf方法
    BigDecimal b1 = new BigDecimal("0.1");
    BigDecimal b2 = BigDecimal.valueOf(0.1);【此方法内部执行了Double的toString，按double实际能表达的精度进行了截断】
 ii)BigDecimal的等值比较应使用compareTo()，不能使用equals()
    equals()会比较值和精度(如1.0和1.00会返回false)，而compareTo()只比较值

3.RESTful API 设计规范:https://github.com/godruoyi/restful-api-specification

4.static:被static修饰的变量、被static修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的。类的初始化早于类的new

5.BeanUtils.copyProperties不能拷贝List和数组属性。属性名相同但类型不同的属性不可拷贝

6.@JsonFormat和@DateTimeFormat
  i)@JsonFormat:1.可以把后端传给前端的Date转成时间字符串；
                2.可以把前端传给后端的时间字符串转成Date，但只适用于使用@RequestBody接受参数(即POST,PUT请求,因为是使用json封装的body)
    pattern:是你需要转换的时间日期的格式
    timezone：是时间设置为东八区，避免时间在转换中少8小时.
    例如： @JsonFormat(pattern="yyyy-MM-dd",timezone="GMT+8")
           private Date sourceDateStart;
 ii)@DatetimeFormat:一般是由前端传值给后端时,将String转换成Date类型。但是只适用于使用类似@RequestParam接受参数。即GET请求，url拼接的参数才生效，在@RequestBody下是无效的。
    例如：  @DateTimeFormat(pattern = "yyyy-MM-dd")
           private Date sourceDateStart;

7.Java数字转字符串自动补0的实现
      int n = 19;
      //%0代表前面补充0, 4代表长度为4, d代表参数为十进制整数
      String str = String.format("%04d", n);
      System.out.println(str); //0019

8.HashMap相关：https://baijiahao.baidu.com/s?id=1662733945029523270&wfr=spider&for=pc

9.事务注解 @Transactional：https://blog.csdn.net/yuanlaishini2010/article/details/45792069

10.@Transactional注解失效的3种场景(https://mp.weixin.qq.com/s/NzuCMuVx2OsvTmcIxhAFIA)：
   i)Transactional注解标注方法修饰符为非public时
     分析：@Transactional是基于动态代理实现的，标注@Transactional的方法如果修饰符不是public，那么就默认方法的@Transactional信息为空，那么将不会对bean实例进行代理对象创建或者不会对方法进行代理调用
  ii)在类内部调用调用类内部@Transactional标注的方法(同一个类中调用)
     分析：同上，事务管理是基于动态代理对象的代理逻辑实现的，如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过了代理对象，那么肯定也没有代理逻辑了
     解决：在同一个类中不直接调用，而通过自身实现的接口调用，也能开启事务管理（可以但没必要）
 iii)事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚
     分析：事务想要回滚，必须能够在代理逻辑中捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚
